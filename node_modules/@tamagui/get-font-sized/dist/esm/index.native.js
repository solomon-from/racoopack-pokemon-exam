import { getTokens } from "@tamagui/core";
function _define_property(obj, key, value) {
  return key in obj ? Object.defineProperty(obj, key, {
    value,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : obj[key] = value, obj;
}
function _object_spread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {}, ownKeys = Object.keys(source);
    typeof Object.getOwnPropertySymbols == "function" && (ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
      return Object.getOwnPropertyDescriptor(source, sym).enumerable;
    }))), ownKeys.forEach(function(key) {
      _define_property(target, key, source[key]);
    });
  }
  return target;
}
var getFontSized = function() {
  var sizeTokenIn = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "$true", _ref = arguments.length > 1 ? arguments[1] : void 0, font = _ref.font, fontFamily = _ref.fontFamily, props = _ref.props, _font_lineHeight, _font_weight, _font_letterSpacing, _font_transform, _font_style, _font_color;
  if (!font) {
    process.env.NODE_ENV === "development" && console.warn("Warning: No font found in props", _object_spread({}, props), 'For a sized text component, you either need to set fontFamily directly, or through the "defaultFont" setting in your createTamagui config.');
    return;
  }
  var sizeToken = sizeTokenIn === "$true" ? getDefaultSizeToken(font) : sizeTokenIn, fontSize = font.size[sizeToken], lineHeight = (_font_lineHeight = font.lineHeight) === null || _font_lineHeight === void 0 ? void 0 : _font_lineHeight[sizeToken], fontWeight = (_font_weight = font.weight) === null || _font_weight === void 0 ? void 0 : _font_weight[sizeToken], letterSpacing = (_font_letterSpacing = font.letterSpacing) === null || _font_letterSpacing === void 0 ? void 0 : _font_letterSpacing[sizeToken], textTransform = (_font_transform = font.transform) === null || _font_transform === void 0 ? void 0 : _font_transform[sizeToken], _props_fontStyle, fontStyle = (_props_fontStyle = props.fontStyle) !== null && _props_fontStyle !== void 0 ? _props_fontStyle : (_font_style = font.style) === null || _font_style === void 0 ? void 0 : _font_style[sizeToken], _props_color, color = (_props_color = props.color) !== null && _props_color !== void 0 ? _props_color : (_font_color = font.color) === null || _font_color === void 0 ? void 0 : _font_color[sizeToken], style = {
    color,
    fontStyle,
    textTransform,
    fontFamily,
    fontWeight,
    letterSpacing,
    fontSize,
    lineHeight
  };
  return process.env.NODE_ENV === "development" && props.debug && props.debug === "verbose" && (console.groupCollapsed("  \u{1F539} getFontSized", sizeTokenIn, sizeToken), console.info({
    style,
    props,
    font
  }), console.groupEnd()), style;
}, cache = /* @__PURE__ */ new WeakMap();
function getDefaultSizeToken(font) {
  if (typeof font == "object" && cache.has(font))
    return cache.get(font);
  var sizeTokens = "$true" in font.size ? font.size : getTokens().size, sizeDefault = sizeTokens.$true, sizeDefaultSpecific = sizeDefault ? Object.keys(sizeTokens).find(function(x) {
    return x !== "$true" && sizeTokens[x].val === sizeDefault.val;
  }) : null;
  return !sizeDefault || !sizeDefaultSpecific ? (process.env.NODE_ENV === "development" && console.warn(`No default size is set in your tokens for the "true" key, fonts will be inconsistent.

      Fix this by having consistent tokens across fonts and sizes and setting a true key for your size tokens, or
      set true keys for all your font tokens: "size", "lineHeight", "fontStyle", etc.`), Object.keys(font.size)[3]) : (cache.set(font, sizeDefaultSpecific), sizeDefaultSpecific);
}
export {
  getFontSized
};
//# sourceMappingURL=index.js.map
